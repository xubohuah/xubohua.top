{
    "version": "https://jsonfeed.org/version/1",
    "title": "Bohua xu",
    "home_page_url": "https://antfu.me/",
    "feed_url": "https://antfu.me/feed.json",
    "description": "bohua xu' Blog",
    "icon": "https://s1.imgbed.xyz/2022/09/23/kSyVq.png",
    "author": {
        "name": "Bohua xu",
        "url": "https://antfu.me"
    },
    "items": [
        {
            "content_html": "<p>[[toc]]</p>\n<!-- > Slides: [PDF](https://antfu.me/talks/2022-01-26) | [SPA](https://talks.antfu.me/2022/vue-nation)\n>\n> Recording: [YouTube](https://www.youtube.com/watch?v=CW9uTys0li0)\n>\n> Made with <Slidev class=\"inline\"/>  [**Slidev**](https://github.com/slidevjs/slidev) - presentation slides for developers. -->\n<h1>可选链操作符（?.）</h1>\n<pre><code class=\"language-js\">// const CallALl = (...fns) =&gt;{\n//   return (...args) =&gt; {\n//     fns.forEach(fn=&gt;\n//      fn&amp;&amp;fn(args)\n//     )\n//   }\n// }\nconst callAll = (...fns) =&gt; (...args) =&gt; fns.forEach(fn =&gt; fn?.(...args))\n//最近的使用，用来传递多个函数来调用,的简写的一个CallAll函数\nconst toggle = () =&gt; console.log('5')\nconst hh = (aet,hhh) =&gt;{\n  console.log(aet,hhh)\n}\n\nconst jh = CallALl(hh, toggle)\n// jh(444,5555)\n// const callAll = (...fns) =&gt; (...args) =&gt; fns.forEach(fn =&gt; fn?.(...args))\n// const hh = (hhh) =&gt;{\n//   console.log(hhh)\n// }\n// console.log(hh?.(888))\nconst s = {\n  x:1\n}\ns.x=0\nconsole.log(s?.x)\nconsole.log(s.x)\n</code></pre>\n<p><strong>可选链</strong>操作符 ( <strong><code>?.</code></strong> ) 允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。<code>?.</code> 操作符的功能类似于 <code>.</code> 链式操作符，不同之处在于，在引用为空 (<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Nullish\">nullish</a> ) (<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/null\"><code>null</code></a> 或者 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined\"><code>undefined</code></a>) 的情况下不会引起错误，该表达式短路返回值是 <code>undefined</code>。与函数调用一起使用时，如果给定的函数不存在，则返回 <code>undefined</code>。</p>\n<p>当尝试访问可能不存在的对象属性时，可选链操作符将会使表达式更短、更简明。在探索一个对象的内容时，如果不能确定哪些属性必定存在，可选链操作符也是很有帮助的。</p>\n<h2><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Optional_chaining#%E5%B0%9D%E8%AF%95%E4%B8%80%E4%B8%8B\">尝试一下</a></h2>\n<iframe class=\"interactive is-taller-height\" height=\"200\" src=\"https://interactive-examples.mdn.mozilla.net/pages/js/expressions-optionalchainingoperator.html\" title=\"MDN Web Docs Interactive Example\" loading=\"lazy\" data-readystate=\"complete\" style=\"box-sizing: border-box; border: 0px; max-width: 100%; width: 723.636px; background-color: var(--background-secondary); border-radius: var(--elem-radius); color: var(--text-primary); height: 654px; margin: 1rem 0px; padding: 0px;\"></iframe>\n<h2><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Optional_chaining#%E8%AF%AD%E6%B3%95\">语法</a></h2>\n<pre><code class=\"language-js\">obj?.prop\nobj?.[expr]\narr?.[index]\nfunc?.(args)\n</code></pre>\n<h2><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Optional_chaining#%E6%8F%8F%E8%BF%B0\">描述</a></h2>\n<p>通过连接的对象的引用或函数可能是 <code>undefined</code> 或 <code>null</code> 时，可选链操作符提供了一种方法来简化被连接对象的值访问。</p>\n<p>比如，思考一个存在嵌套结构的对象 <code>obj</code>。不使用可选链的话，查找一个深度嵌套的子属性时，需要验证之间的引用，例如：</p>\n<pre><code class=\"language-js\">let nestedProp = obj.first &amp;&amp; obj.first.second;\n</code></pre>\n<p>为了避免报错，在访问<code>obj.first.second</code>之前，要保证 <code>obj.first</code> 的值既不是 <code>null</code>，也不是 <code>undefined</code>。如果只是直接访问 <code>obj.first.second</code>，而不对 <code>obj.first</code> 进行校验，则有可能抛出错误。</p>\n<p>有了可选链操作符（<code>?.</code>），在访问 <code>obj.first.second</code> 之前，不再需要明确地校验 <code>obj.first</code> 的状态，再并用短路计算获取最终结果：</p>\n<pre><code class=\"language-js\">let nestedProp = obj.first?.second;\n</code></pre>\n<p>通过使用 <code>?.</code> 操作符取代 <code>.</code> 操作符，JavaScript 会在尝试访问 <code>obj.first.second</code> 之前，先隐式地检查并确定 <code>obj.first</code> 既不是 <code>null</code> 也不是 <code>undefined</code>。如果<code>obj.first</code> 是 <code>null</code> 或者 <code>undefined</code>，表达式将会短路计算直接返回 <code>undefined</code>。</p>\n<p>这等价于以下表达式，但实际上没有创建临时变量：</p>\n<pre><code class=\"language-js\">let temp = obj.first;\nlet nestedProp = ((temp === null || temp === undefined) ? undefined : temp.second);\n</code></pre>\n<p>Copy to Clipboard</p>\n<h3><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Optional_chaining#%E5%8F%AF%E9%80%89%E9%93%BE%E4%B8%8E%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8\">可选链与函数调用</a></h3>\n<p>当尝试调用一个可能不存在的方法时也可以使用可选链。这将是很有帮助的，比如，当使用一个 API 的方法可能不可用时，要么因为实现的版本问题要么因为当前用户的设备不支持该功能。</p>\n<p>函数调用时如果被调用的方法不存在，使用可选链可以使表达式自动返回<code>undefined</code>而不是抛出一个异常。</p>\n<pre><code class=\"language-js\">let result = someInterface.customMethod?.();\n</code></pre>\n<p><strong>备注：</strong> 如果存在一个属性名且不是函数，使用 <code>?.</code> 仍然会产生一个 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError\"><code>TypeError</code></a> 异常 (<code>x.y is not a function</code>).</p>\n<p><strong>备注：</strong> 如果 <code>someInterface</code> 自身是 <code>null</code> 或者 <code>undefined</code> ，异常 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError\"><code>TypeError</code></a> 仍会被抛出 <code>someInterface is null</code> 如果你希望允许 <code>someInterface</code> 也为 <code>null</code> 或者 <code>undefined</code> ，那么你需要像这样写 <code>someInterface?.customMethod?.()</code></p>\n<h4>处理可选的回调函数或者事件处理器</h4>\n<p>如果使用<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\">解构赋值</a>来解构的一个对象的回调函数或 fetch 方法，你可能得到不能当做函数直接调用的不存在的值，除非你已经校验了他们的存在性。使用<code>?.</code>的你可以忽略这些额外的校验：</p>\n<pre><code class=\"language-js\">//  ES2019 的写法\nfunction doSomething(onContent, onError) {\n  try {\n    // ... do something with the data\n  }\n  catch (err) {\n    if (onError) { // 校验 onError 是否真的存在\n      onError(err.message);\n    }\n  }\n}\n</code></pre>\n<pre><code class=\"language-js\">// 使用可选链进行函数调用\nfunction doSomething(onContent, onError) {\n  try {\n   // ... do something with the data\n  }\n  catch (err) {\n    onError?.(err.message); // 如果 onError 是 undefined 也不会有异常\n  }\n}\n</code></pre>\n<h3><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Optional_chaining#%E5%8F%AF%E9%80%89%E9%93%BE%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F\">可选链和表达式</a></h3>\n<p>当使用<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Property_Accessors#%E6%96%B9%E6%8B%AC%E5%8F%B7%E8%A1%A8%E7%A4%BA%E6%B3%95\">方括号与属性名</a>的形式来访问属性时，你也可以使用可选链操作符：</p>\n<pre><code class=\"language-js\">let nestedProp = obj?.['prop' + 'Name'];\n</code></pre>\n<h3><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Optional_chaining#%E5%8F%AF%E9%80%89%E9%93%BE%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%8E%E8%B5%8B%E5%80%BC\">可选链不能用于赋值</a></h3>\n<pre><code class=\"language-js\">let object = {};\nobject?.property = 1; // Uncaught SyntaxError: Invalid left-hand side in assignment\n</code></pre>\n<h3><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Optional_chaining#%E5%8F%AF%E9%80%89%E9%93%BE%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0\">可选链访问数组元素</a></h3>\n<pre><code class=\"language-js\">let arrayItem = arr?.[42];\n</code></pre>\n<h2><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Optional_chaining#%E4%BE%8B%E5%AD%90\">例子</a></h2>\n<h3><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Optional_chaining#%E5%9F%BA%E6%9C%AC%E4%BE%8B%E5%AD%90\">基本例子</a></h3>\n<p>如下的例子在一个不含 <code>bar</code> 成员的 Map 中查找 <code>bar</code> 成员的 <code>name</code> 属性，因此结果是 <code>undefined</code>。</p>\n<pre><code class=\"language-js\">let myMap = new Map();\nmyMap.set(&quot;foo&quot;, {name: &quot;baz&quot;, desc: &quot;inga&quot;});\n\nlet nameBar = myMap.get(&quot;bar&quot;)?.name;\n</code></pre>\n<h3><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Optional_chaining#%E7%9F%AD%E8%B7%AF%E8%AE%A1%E7%AE%97\">短路计算</a></h3>\n<p>当在表达式中使用可选链时，如果左操作数是 <code>null</code> 或 <code>undefined</code>，表达式将不会被计算，例如：</p>\n<pre><code class=\"language-js\">let potentiallyNullObj = null;\nlet x = 0;\nlet prop = potentiallyNullObj?.[x++];\n\nconsole.log(x); // x 将不会被递增，依旧输出 0\n</code></pre>\n<h3><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Optional_chaining#%E8%BF%9E%E7%94%A8%E5%8F%AF%E9%80%89%E9%93%BE%E6%93%8D%E4%BD%9C%E7%AC%A6\">连用可选链操作符</a></h3>\n<p>可以连续使用可选链读取多层嵌套结构：</p>\n<pre><code class=\"language-js\">let customer = {\n  name: &quot;Carl&quot;,\n  details: {\n    age: 82,\n    location: &quot;Paradise Falls&quot; // details 的 address 属性未有定义\n  }\n};\nlet customerCity = customer.details?.address?.city;\n\n// … 可选链也可以和函数调用一起使用\nlet duration = vacations.trip?.getTime?.();\n</code></pre>\n<h3><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Optional_chaining#%E4%BD%BF%E7%94%A8%E7%A9%BA%E5%80%BC%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C%E7%AC%A6\">使用空值合并操作符</a></h3>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator\"><code>空值合并操作符</code></a>可以在使用可选链时设置一个默认值：</p>\n<pre><code class=\"language-js\">let customer = {\n  name: &quot;Carl&quot;,\n  details: { age: 82 }\n};\nlet customerCity = customer?.city ?? &quot;暗之城&quot;;\nconsole.log(customerCity); // “暗之城”\n</code></pre>\n<h2>MDN</h2>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Optional_chaining\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Optional_chaining</a></p>\n",
            "url": "https://antfu.me/posts/jottingsl",
            "title": "?.",
            "summary": "Compound Components",
            "date_modified": "2022-08-26T08:00:00.000Z",
            "author": {
                "name": "Bohua xu",
                "url": "https://antfu.me"
            }
        },
        {
            "content_html": "<p>[[toc]]</p>\n<h2>useContext</h2>\n<pre><code class=\"language-js\">const CountContext = React.createContext()\n//CountProvider和useCount写在外部导入\nfunction CountProvider(props) {\n  const [count, setCount] = React.useState(0)\n  const value = [count, setCount]\n  return &lt;CountContext.Provider value={value} {...props} /&gt;\n}\n\nfunction useCount() {                        //封装useCount\n  const context = React.useContext(CountContext)\n  if (!context) {\n    throw new Error('useCount must be used within a CountProvider')\n  }\n  return context\n}\n\nfunction CountDisplay() {\n  const [count] = useCount()\n  return &lt;div&gt;{`The current count is ${count}`}&lt;/div&gt;\n}\n\nfunction Counter() {\n  const [, setCount] = useCount()\n  const increment = () =&gt; setCount(c =&gt; c + 1)\n  return &lt;button onClick={increment}&gt;Increment count&lt;/button&gt;\n}\n\nfunction App() {\n  return (\n    &lt;div&gt;\n      &lt;CountProvider&gt;\n        &lt;CountDisplay /&gt;\n        &lt;Counter /&gt;\n      &lt;/CountProvider&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre>\n<pre><code class=\"language-js\">const CountContext = React.createContext()\n\nfunction CountProvider(props) {\n  const [count, setCount] = React.useState(0)\n  const value = [count, setCount]\n  // const value = React.useState(0)\n  return &lt;CountContext.Provider value={value} {...props} /&gt;\n}\n\nfunction CountDisplay() {\n  const [count] = React.useContext(CountContext)\n  return &lt;div&gt;{`The current count is ${count}`}&lt;/div&gt;\n}\n\nfunction Counter() {\n  const [, setCount] = React.useContext(CountContext)\n  const increment = () =&gt; setCount(c =&gt; c + 1)\n  return &lt;button onClick={increment}&gt;Increment count&lt;/button&gt;\n}\n\nfunction App() {\n  return (\n    &lt;div&gt;\n      &lt;CountProvider&gt;\n        &lt;CountDisplay /&gt;\n        &lt;Counter /&gt;\n      &lt;/CountProvider&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre>\n<h2>配合useReducer使用</h2>\n<p>CounterCotext.jsx</p>\n<pre><code class=\"language-js\">const CounterContext = React.createContext(null)\nexport default CounterContext\n</code></pre>\n<p>CounterReducer.jsx</p>\n<pre><code class=\"language-js\">const CounterReducer = (state,action)=&gt;{\n    switch (action.type){\n        case 'counter/increment':\n         return state + 1;\n        case 'counter/decrement':\n         return state - 1;\n        default:\n         return state;\n    }\n}\nexport default CounterReducer\n</code></pre>\n<p>App.jsx</p>\n<pre><code class=\"language-js\">import  CounterContext\nimport  CounterReducer\n\nfunction App() {\n  const [state,dispacth] = React.useReducer(CounterReducer,0)\n    \n  return (\n    &lt;div&gt;\n      &lt;CounterContext.Provider value={{state,dispath}}&gt;\n        &lt;Counter /&gt;\n      &lt;/CounterContext.Provider&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre>\n<p>Counter.jsx</p>\n<pre><code class=\"language-js\">import  useContext\n\nconst Counter = () =&gt;{\n const count = React.useContext(CounterContext)\n const dispatch = count.dispatch\n    \n return (\n    &lt;div&gt;\n      &lt;button onClick={()=&gt;{dispatch({type:'counter/increment'})}}&gt;&lt;/button&gt;\n      &lt;span&gt;{count.state}&lt;/span&gt;\n      &lt;button onClick={()=&gt;{dispatch({type:'counter/decrement'})}}&gt;&lt;/button&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre>\n",
            "url": "https://antfu.me/posts/destructuring-with-object-or-array",
            "title": "useContext -useReducer",
            "summary": "Prefer object destructure or array? Can we support both?",
            "image": "https://antfu.me/images/destructuring.png",
            "date_modified": "2021-12-21T16:00:00.000Z",
            "author": {
                "name": "Bohua xu",
                "url": "https://antfu.me"
            }
        }
    ]
}